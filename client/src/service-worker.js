/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.

importScripts(
  'https://storage.googleapis.com/workbox-cdn/releases/6.5.4/workbox-sw.js'
);

// Use workbox from importScripts
const { clientsClaim } = workbox.core;
const { ExpirationPlugin } = workbox.expiration;
const { precacheAndRoute, createHandlerBoundToURL } = workbox.precaching;
const { registerRoute } = workbox.routing;
const { StaleWhileRevalidate, CacheFirst } = workbox.strategies;

// Immediately take control of the page to avoid waiting for reload
clientsClaim();

// Define a manual manifest if __WB_MANIFEST is not available
// Define core assets to cache
const CORE_ASSETS = [
  { url: '/', revision: '1' },
  { url: '/index.html', revision: '1' },
  { url: '/manifest.json', revision: '1' },
  { url: '/favicon.ico', revision: '1' },
  { url: '/logo192.png', revision: '1' },
  { url: '/logo512.png', revision: '1' },
  { url: '/maskable_icon.png', revision: '1' },
];

// Add current path-based assets
const pathPrefix = self.location.pathname.replace(/\/service-worker\.js$/, '');
const BASE_MANIFEST = CORE_ASSETS.map(asset => ({
  url: asset.url.startsWith('/') ? `${pathPrefix}${asset.url}` : asset.url,
  revision: asset.revision
}));

// Precache all the assets generated by your build process
// Try to use __WB_MANIFEST if available, otherwise use our base manifest
console.log('Precaching assets with service worker');
precacheAndRoute(self.__WB_MANIFEST || BASE_MANIFEST);

// Handle assets URLs 
registerRoute(
  // Match all URLs that end with a file extension
  ({ request }) => request.destination === 'style' || 
                  request.destination === 'script' ||
                  request.destination === 'font',
  new StaleWhileRevalidate({
    cacheName: 'assets-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// Cache images separately with a cache-first strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 60,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
      }),
    ],
  })
);

// Set up navigation routes to always go through index.html
// This is needed for SPA with client-side routing
registerRoute(
  // Check to see if the request is a navigation
  ({ request }) => request.mode === 'navigate',
  // Use a network-first strategy for HTML pages
  new StaleWhileRevalidate({
    cacheName: 'pages-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
      }),
    ],
  })
);

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
});

// Handle offline fallback when network is unavailable
self.addEventListener('fetch', (event) => {
  // Only handle navigate requests (page loads)
  if (event.request.mode === 'navigate') {
    event.respondWith(
      fetch(event.request)
        .catch(() => {
          // If fetch fails (offline), return the cached index page
          return caches.match('/index.html')
            .then(response => {
              if (response) {
                return response;
              }
              // If we can't find /index.html, try with the path prefix
              const pathPrefix = self.location.pathname.replace(/\/service-worker\.js$/, '');
              return caches.match(`${pathPrefix}/index.html`) || caches.match('/');
            });
        })
    );
  }
});